 % Devoir : fabriquer une grille sinusoidale bleue et jaune (a partir de la fonction fabriquer_grille_sin) revelee % partiellement par une fenetre gaussienne (a partir de la fonction% fabriquer_enveloppe_gauss).% En partant de fabriquer_grille_sin :im = zeros(256, 256, 3);gauss = fabriquer_enveloppe_gauss(256, 3);im(:,:,1) = (fabriquer_grille_sin(256, 1, 5, pi, pi/2)-.5) .* gauss + .5;im(:,:,2) =(fabriquer_grille_sin(256, 1, 5, pi, pi/2)-.5) .* gauss + .5;im(:,:,3) = (fabriquer_grille_sin(256, 1, 5, 0, pi/2)-.5) .* gauss + .5;figure, imshow(im)% En partant de fabriquer_gabor :im = zeros(512, 512, 3);im(:,:,1) = fabriquer_gabor(512, 1, 10, pi, pi/5, 3);im(:,:,2) = fabriquer_gabor(512, 1, 10, pi, pi/5, 3);im(:,:,3) = fabriquer_gabor(512, 1, 10, 0, pi/5, 3);figure, imshow(im)% PsychtoolboxAssertOpenGL;% screen : http://psychtoolbox.org/% en tapant 'Screen' on obtient (most useful only listed underneath) :% Usage:% % % Get (and set) information about a window or screen:% screenNumbers=Screen('Screens' [, physicalDisplays]);screens=Screen('Screens');screenNumber=max(screens); % va toujours chercher l'écran secondaire% % Open or close a window or texture:% [windowPtr,rect]=Screen('OpenWindow',windowPtrOrScreenNumber [,color] [,rect] [,pixelSize] [,numberOfBuffers] [,stereomode] [,multisample][,imagingmode]);[windowPtr,rect]=Screen('OpenWindow', screenNumber);% Screen('CloseAll');sca[windowPtr,rect]=Screen('OpenWindow',screenNumber, [0 255 0]);% possible que vous soyez obligés d'ajouter la ligne suivante:Screen('Preference', 'SkipSyncTests', 0);    % put 1 if the sync test fails%  Draw lines and solids like QuickDraw and DirectX (OS 9 and Windows):% Screen('DrawLine', windowPtr [,color], fromH, fromV, toH, toV [,penWidth]);% Screen('DrawArc',windowPtr,[color],[rect],startAngle,arcAngle)% Screen('FrameArc',windowPtr,[color],[rect],startAngle,arcAngle[,penWidth] [,penHeight] [,penMode])% Screen('FillArc',windowPtr,[color],[rect],startAngle,arcAngle)% Screen('FillRect', windowPtr [,color] [,rect] );% Screen('FrameRect', windowPtr [,color] [,rect] [,penWidth]);% Screen('FillOval', windowPtr [,color] [,rect]);% Screen('FrameOval', windowPtr [,color] [,rect] [,penWidth] [,penHeight] [,penMode]);% Screen('FramePoly', windowPtr [,color], pointList [,penWidth]);% Screen('FillPoly', windowPtr [,color], pointList);Screen('DrawLine', windowPtr, [255 0 0], 200, 100, 200, 200, 5);% Rien? Parce que dessine sur le tampon, pas sur l'ecran directement. Il% faut ensuite "flip" le tampon sur l'ecran:% % Synchronize with the window's screen (on-screen only):% [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos] = Screen('Flip', windowPtr [, when] [, dontclear] [, dontsync] [, multiflip]);Screen('Flip', windowPtr);% Fabrique un MondrianScreen('Preference', 'SkipSyncTests', 1);screens=Screen('Screens');screenNumber=max(screens); % va toujours chercher l'écran secondaire[windowPtr,rect]=Screen('OpenWindow',screenNumber);xx = rect(3) - rect(1);yy = rect(4) - rect(2);for ii = 1:100,	ax = round(xx * rand);	bx = round(xx * rand);	ay = round(yy * rand);	by = round(yy * rand);		Screen('FillOval', windowPtr, uint8(255*rand(1,3)), [min(ax, bx), min(ay, by), max(ax, bx), max(ay, by)])	ax = round(xx * rand);	bx = round(xx * rand);	ay = round(yy * rand);	by = round(yy * rand);		Screen('FillRect', windowPtr, uint8(255*rand(1,3)), [min(ax, bx), min(ay, by), max(ax, bx), max(ay, by)])	ax = round(xx * rand);	bx = round(xx * rand);	ay = round(yy * rand);	by = round(yy * rand);		Screen('DrawLine', windowPtr, uint8(255*rand(1,3)),ax,ay,bx,by,ceil(5*rand))endScreen('Flip', windowPtr);WaitSecs(2); sca;% % Draw Text in windows% oldTextSize=Screen('TextSize', windowPtr [,textSize]);% [oldFontName,oldFontNumber]=Screen(windowPtr,'TextFont' [,fontNameOrNumber]);% [newX,newY]=Screen('DrawText', windowPtr, text [,x] [,y] [,color] [,backgroundColor] [,yPositionIsBaseline]);% oldTextColor=Screen('TextColor', windowPtr [,colorVector]);[windowPtr,rect]=Screen('OpenWindow',screenNumber);% Screen('TextSize', windowPtr, 100);% Screen('TextColor', windowPtr, [255 0 0])% Screen(windowPtr,'TextFont', 'Helvetica');Screen('DrawText', windowPtr, 'OK', 200, 200);Screen('Flip', windowPtr);% Fabrique un "Mondrian meets Basquiat"Screen('Preference', 'SkipSyncTests', 1);screens=Screen('Screens');screenNumber=max(screens); % va toujours chercher l'écran secondaire[windowPtr,rect]=Screen('OpenWindow',screenNumber);xx = rect(3) - rect(1);yy = rect(4) - rect(2);for ii = 1:100,	ax = round(xx * rand);	bx = round(xx * rand);	ay = round(yy * rand);	by = round(yy * rand);		Screen('FillOval', windowPtr, uint8(255*rand(1,3)), [min(ax, bx), min(ay, by), max(ax, bx), max(ay, by)])	ax = round(xx * rand);	bx = round(xx * rand);	ay = round(yy * rand);	by = round(yy * rand);		Screen('FillRect', windowPtr, uint8(255*rand(1,3)), [min(ax, bx), min(ay, by), max(ax, bx), max(ay, by)])	ax = round(xx * rand);	bx = round(xx * rand);	ay = round(yy * rand);	by = round(yy * rand);		Screen('DrawLine', windowPtr, uint8(255*rand(1,3)),ax,ay,bx,by,ceil(10*rand))    ax = round(xx * rand);	ay = round(yy * rand);    n = ceil(9*rand);    mot = ceil((double('z')-double('a')+1)*rand(1,n)+double('a')-1);    Screen('TextSize', windowPtr, ceil(100*rand));    Screen('DrawText', windowPtr, char(mot), ax, ay, [0 0 0]);endScreen('Flip', windowPtr);WaitSecs(2);sca;% % Open or close a window or texture, suite% textureIndex=Screen('MakeTexture', WindowIndex, imageMatrix [, optimizeForDrawAngle=0] [, specialFlags=0] [, floatprecision=0] [, textureOrientation=0] [, textureShader=0]); % Damier changeant de polarite a tous les "period" s period = 0.1; % s[windowPtr,rect]=Screen('OpenWindow',screenNumber, [128 128 128]);[monitorFlipInterval nrValidSamples stddev] = Screen('GetFlipInterval', windowPtr);im1 = uint8(255*fabriquer_grand_damier(16, 8));im2 = uint8(255*(1-fabriquer_grand_damier(16, 8)));texturePtr(1) = Screen('MakeTexture', windowPtr, im1);texturePtr(2) = Screen('MakeTexture', windowPtr, im2);start = GetSecs;while GetSecs<(start+5),    Screen('DrawTexture', windowPtr, texturePtr(1));    Screen('Flip', windowPtr);    WaitSecs(period-monitorFlipInterval/2);    Screen('DrawTexture', windowPtr, texturePtr(2));    Screen('Flip', windowPtr);    WaitSecs(period-monitorFlipInterval/2);endsca% Idem mais revele a travers une ouverture gaussienneperiod = 0.1; % s[windowPtr,rect]=Screen('OpenWindow',screenNumber, [128 128 128]);[monitorFlipInterval nrValidSamples stddev] = Screen('GetFlipInterval', windowPtr);im1 = uint8(255*((fabriquer_grand_damier(16, 8)-.5).*fabriquer_enveloppe_gauss(256, 3)+.5));im2 = uint8(255*(((1-fabriquer_grand_damier(16, 8))-.5).*fabriquer_enveloppe_gauss(256, 3)+.5));texturePtr(1) = Screen('MakeTexture', windowPtr, im1);texturePtr(2) = Screen('MakeTexture', windowPtr, im2);buttons = 0;while sum(buttons)==0,    [xCoor, yCoor, buttons] = GetMouse;    Screen('DrawTexture', windowPtr, texturePtr(1));    Screen('Flip', windowPtr);    WaitSecs(period-monitorFlipInterval/2);    Screen('DrawTexture', windowPtr, texturePtr(2));    Screen('Flip', windowPtr);    WaitSecs(period-monitorFlipInterval/2);endsca% Idem mais revele a travers une ouverture gaussienneperiod = 0.1; % sscreenNumber = 0;[windowPtr,rect]=Screen('OpenWindow',screenNumber, [128 128 128]);[monitorFlipInterval nrValidSamples stddev] = Screen('GetFlipInterval', windowPtr);im1 = uint8(255*((fabriquer_grand_damier(16, 8)-.5).*fabriquer_enveloppe_gauss(256, 3)+.5));im2 = uint8(255*(((1-fabriquer_grand_damier(16, 8))-.5).*fabriquer_enveloppe_gauss(256, 3)+.5));texturePtr(1) = Screen('MakeTexture', windowPtr, im1);texturePtr(2) = Screen('MakeTexture', windowPtr, im2);[VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos] = Screen('Flip', windowPtr);while GetSecs<StimulusOnsetTime+5,    for frame = 1:2,        [VBLTimestamp StimulusOnsetTime FlipTimestamp Missed Beampos] = Screen('Flip', windowPtr);        while GetSecs<StimulusOnsetTime+period-monitorFlipInterval/2,            Screen('DrawTexture', windowPtr, texturePtr(frame));                    end    endend% Devoir : presenter une grille sinusoidale derriere une ouverture% gaussienne en mouvement a une vitesse x au centre de l'ecran avec le Psychtoolbox.% Devoir : presenter deux grilles sinusoidales derriere une ouverture% gaussienne en mouvement a des vitesses x et y au centre de l'ecran avec le Psychtoolbox.